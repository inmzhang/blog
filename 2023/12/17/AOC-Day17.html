<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>AOC2023 Day17: Shortest path | Inm&#x27;s Blog</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
<meta name="description" content="Inm Zhang's personal blog.">
    <!-- favicons -->
<link rel="icon" type="image/svg+xml" href="../../../images/cuddlyferris.svg">
<!-- styles -->
<link rel="stylesheet" href="../../../styles/vendor.css"/>
<link rel="stylesheet" href="../../../styles/fonts.css"/>
<link rel="stylesheet" href="../../../styles/app.css"/>
<link rel="stylesheet" href="../../../styles/highlight.css"/>
<link rel="stylesheet" href="../../../styles/katex.css"/>

  </head>
  <body>
    <nav class="flex flex-row justify-center justify-end-l items-center flex-wrap ph2 pl3-ns pr4-ns">
  <div class="brand flex-auto w-100 w-auto-l self-start tc tl-l">
    <a href="../../../">
     <img class="v-mid ml0-l" alt="Ferris Logo" src="../../../images/cuddlyferris.svg"> 
     <span class="dib ml1 ml0-l">Inm&#x27;s Blog</span>
    </images>
  </div>
  
  <ul class="nav list w-100 w-auto-l flex flex-none flex-row flex-wrap justify-center justify-end-l items-center pv2 ph0 ph4-ns">
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://inmzhang.github.io/paste">Clipboard</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://github.com/inmzhang">Github</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://scholar.google.com/citations?user=fhTGnZwAAAAJ&hl=en">Scholar</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://github.com/inmzhang/blog">Source</a></li>
  </ul>
</nav>

<section id="AOC2023 Day17: Shortest path" class="white">
  <div class="w-100 mw-none ph3 mw8-m mw8-l center f3">
    <header>
      <h2>AOC2023 Day17: Shortest path</h2>
      <div class="highlight mt2 mb3"></div>
    </header>

    <div class="publish-date-author">Dec. 17, 2023 &middot; Yiming Zhang
    
    </div>

    <div class="post">
      <p>Today's AOC puzzel is about <em>Single-Source Shortes Path</em>(SSSP) problem. It's a good
time for me to review the Dijkstra's algorithm. And I learned a new algorithm <em>A*</em>
to test against the former.</p>
<h2><a href="#the-puzzel" aria-hidden="true" class="anchor" id="the-puzzel"></a>The puzzel</h2>
<p>Given the input as follow:</p>
<pre><code class="language-text">2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533
</code></pre>
<p>We will start from the top-left to find a shortest weighted path to the bottom-right.
What's more, the path is constrained that it will not step back and the consequtive
steps in the same direction should be in range [n, m].</p>
<p>For example, given the range [1, 3] and the input above, we have the following shortest
path:</p>
<pre><code class="language-text">2&gt;&gt;34^&gt;&gt;&gt;1323
32v&gt;&gt;&gt;35v5623
32552456v&gt;&gt;54
3446585845v52
4546657867v&gt;6
14385987984v4
44578769877v6
36378779796v&gt;
465496798688v
456467998645v
12246868655&lt;v
25465488877v5
43226746555v&gt;
</code></pre>
<p>Or, given the range [4, 10], we have the following shortest path instead:</p>
<pre><code class="language-text">2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1323
32154535v5623
32552456v4254
34465858v5452
45466578v&gt;&gt;&gt;&gt;
143859879845v
445787698776v
363787797965v
465496798688v
456467998645v
122468686556v
254654888773v
432267465553v
</code></pre>
<p>Before diving into the solution, we need to parse the input firstly:</p>
<pre><code class="language-rust">let blocks: Vec&lt;&amp;[u8]&gt; = input
    .split('\n')
    .map(str::as_bytes)
    .collect();

// we will need to use this for the algorithms
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
struct Node {
    direction: (i32, i32),
    position: (i32, i32),
}
</code></pre>
<h2><a href="#dijkstra-algorithm" aria-hidden="true" class="anchor" id="dijkstra-algorithm"></a>Dijkstra algorithm</h2>
<p>Obviously, the problem can be solved with the variant of the most common
shortest path finding algorithm: Dijkstra algorithm.</p>
<p><img src="../../../images/2023-12-17-AOC-Day17/Dijkstra_Animation.gif" alt="Dijkstra algorithm" /></p>
<p><strong>Dijkstra algorithm</strong> is widely used in shortest path finding problems, i.e.
network routing protocols and constructing syndrom graph for QEC decoding.
The following <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">pseudocodes</a>
illustrates the basic of the algorithm:</p>
<pre><code>function Dijkstra(Graph, source):
     dist[source] ← 0                           // Initialization

     create vertex priority queue Q

     for each vertex v in Graph.Vertices:
         if v ≠ source
             dist[v] ← INFINITY                 // Unknown distance from source to v
             prev[v] ← UNDEFINED                // Predecessor of v

         Q.add_with_priority(v, dist[v])

     while Q is not empty:                      // The main loop
         u ← Q.extract_min()                    // Remove and return best vertex
         for each neighbor v of u:              // Go through all v neighbors of u
             alt ← dist[u] + Graph.Edges(u, v)
             if alt &lt; dist[v]:
                 dist[v] ← alt
                 prev[v] ← u
                 Q.decrease_priority(v, alt)

     return dist, prev
</code></pre>
<p>With the help of the <em>priority queue/heap</em>, the complexity of finding all the shortest path
each nodes of a complete graph is $O(Elog(V))$, where $E, V$ is the total number of edges
and vertices in the graph.</p>
<p>For the puzzel, we need to change the algorithm a bit to account for the direction and moving
constraints:</p>
<pre><code class="language-rust">fn dijkstra(blocks: &amp;[&amp;[u8]], minstep: i32, maxstep: i32) -&gt; u32 {
    let mut costs: HashMap&lt;Node, i32&gt; = HashMap::new();
    // BinaryHeap in std is a max heap
    // Then we need to store -cost
    let mut queue = BinaryHeap::from_iter([(
        0i32, // the cost
        Node {
            direction: (0, 0), // this is the edge case: starting point's direction is not fixed
            position: (0, 0),
        },
    )]);
    // The bounding box
    let max_col = blocks[0].len() as i32 - 1;
    let max_row = blocks.len() as i32 - 1;
    let end = (max_row, max_col);
    while let Some((cost, node)) = queue.pop() {
        // reach the end point
        if node.position == end {
            return -cost as u32;
        }
        // there is already a path with smaller cost
        if costs.get(&amp;node).is_some_and(|&amp;c| -cost &gt; c) {
            continue;
        }
        // move to the next position
        for (dr, dc) in [(1, 0), (-1, 0), (0, 1), (0, -1)] {
            // dont step back and the forth direction have already been considered(see below)
            if node.direction == (dr, dc) || node.direction == (-dr, -dc) {
                continue;
            }
            let mut cost_next = -cost;
            for step in 1..=maxstep {
                let position = (node.position.0 + dr * step, node.position.1 + dc * step);
                // out of bound
                if position.0 &lt; 0 || position.0 &gt; max_row || position.1 &lt; 0 || position.1 &gt; max_col
                {
                    continue;
                }
                cost_next += (blocks[position.0 as usize][position.1 as usize] - b'0') as i32;
                let node_next = Node {
                    direction: (dr, dc),
                    position,
                };
                if minstep &gt; step || *costs.get(&amp;node_next).unwrap_or(&amp;i32::MAX) &lt;= cost_next {
                    continue;
                }
                costs.insert(node_next, cost_next);
                queue.push((-cost_next, node_next));
            }
        }
    }
    unreachable!()
}
</code></pre>
<h2><a href="#a-algorithm" aria-hidden="true" class="anchor" id="a-algorithm"></a>A* algorithm</h2>
<p>A* algorithm can be seen as an extension of <em>Dijkstra algorithm</em>, it uses <strong>heuristics</strong> to guide
the search and achieves better performance(the efficiency depends on the choice of the heuristics).</p>
<p><img src="../../../images/2023-12-17-AOC-Day17/Astar_Animation.gif" alt="Astar algorithm" /></p>
<p>Instead of exploring the edges with the minimum weight first, A* use the heuristics to combine the length
of path so far with the predicted length of path to the desitination.</p>
<p>The following pseudocodes describe the algorithm:</p>
<pre><code>function reconstruct_path(cameFrom, current)
    total_path := {current}
    while current in cameFrom.Keys:
        current := cameFrom[current]
        total_path.prepend(current)
    return total_path

// A* finds a path from start to goal.
// h is the heuristic function. h(n) estimates the cost to reach goal from node n.
function A_Star(start, goal, h)
    // The set of discovered nodes that may need to be (re-)expanded.
    // Initially, only the start node is known.
    // This is usually implemented as a min-heap or priority queue rather than a hash-set.
    openSet := {start}

    // For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from the start
    // to n currently known.
    cameFrom := an empty map

    // For node n, gScore[n] is the cost of the cheapest path from start to n currently known.
    gScore := map with default value of Infinity
    gScore[start] := 0

    // For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to
    // how cheap a path could be from start to finish if it goes through n.
    fScore := map with default value of Infinity
    fScore[start] := h(start)

    while openSet is not empty
        // This operation can occur in O(Log(N)) time if openSet is a min-heap or a priority queue
        current := the node in openSet having the lowest fScore[] value
        if current = goal
            return reconstruct_path(cameFrom, current)

        openSet.Remove(current)
        for each neighbor of current
            // d(current,neighbor) is the weight of the edge from current to neighbor
            // tentative_gScore is the distance from start to the neighbor through current
            tentative_gScore := gScore[current] + d(current, neighbor)
            if tentative_gScore &lt; gScore[neighbor]
                // This path to neighbor is better than any previous one. Record it!
                cameFrom[neighbor] := current
                gScore[neighbor] := tentative_gScore
                fScore[neighbor] := tentative_gScore + h(neighbor)
                if neighbor not in openSet
                    openSet.add(neighbor)

    // Open set is empty but goal was never reached
    return failure
</code></pre>
<p>For the puzzel, I use the sum of costs for the <code>gscore</code> and the manhatten distance between current
node and the desitination as the <code>hscore</code>. Here is the code:</p>
<pre><code class="language-rust">fn astar(blocks: &amp;[&amp;[u8]], minstep: i32, maxstep: i32) -&gt; u32 {
    let start = Node::new((0, 0), (0, 0));
    let max_col = blocks[0].len() as i32 - 1;
    let max_row = blocks.len() as i32 - 1;
    let end = (max_row, max_col);
    let mut gscores: HashMap&lt;Node, i32&gt; = HashMap::from_iter([(start, 0)]);
    let mut queue = BinaryHeap::from_iter([(cal_cost(&amp;start, 0, end), start)]);
    while let Some((cost, node)) = queue.pop() {
        if node.position == end {
            return -cost as u32;
        }
        for (dr, dc) in [(1, 0), (-1, 0), (0, 1), (0, -1)] {
            if node.direction == (dr, dc) || node.direction == (-dr, -dc) {
                continue;
            }
            let mut tentative_gscore = gscores[&amp;node];
            for step in 1..=maxstep {
                let position = (node.position.0 + dr * step, node.position.1 + dc * step);
                if position.0 &lt; 0 || position.0 &gt; max_row || position.1 &lt; 0 || position.1 &gt; max_col
                {
                    continue;
                }
                tentative_gscore +=
                    (blocks[position.0 as usize][position.1 as usize] - b'0') as i32;
                let node_next = Node::new((dr, dc), position);
                if minstep &gt; step
                    || *gscores.get(&amp;node_next).unwrap_or(&amp;i32::MAX) &lt;= tentative_gscore
                {
                    continue;
                }
                gscores.insert(node_next, tentative_gscore);
                queue.push((cal_cost(&amp;node_next, tentative_gscore, end), node_next));
            }
        }
    }
    unreachable!()
}
</code></pre>
<h2><a href="#comparasion" aria-hidden="true" class="anchor" id="comparasion"></a>Comparasion</h2>
<p>The animation from wikipedia illustrates the difference between these two algorithm clearly:</p>
<p><img src="../../../images/2023-12-17-AOC-Day17/Dijkstras_progress_animation.gif" alt="Dijkstra progress animation" />
<em>Dijkstra's algorithm</em>
<img src="../../../images/2023-12-17-AOC-Day17/Astar_progress_animation.gif" alt="A* progress animation" />
<em>A* algorithm</em></p>
<p>The heuristics guides the A* algorithm to explore in the direction of the desitination node rather than
all the directions uniformly as in Dijkstra's algorithm.</p>
<p>As above, I expected the A* implementation would be somewhat faster than the Dijkstra's one.
However, when I benchmarked the code, the A* is ~2x slow! It might results from the non-uniform
distribution of the costs across the grid, so that the uniform manhatten heuristics is not a good
choice.</p>
<p>Here is the benchmark results for the part1 and part2 of the puzzel(the range is [1, 3] and [4, 10]):</p>
<pre><code class="language-text">day_17          fastest       │ slowest       │ median        │ mean          │ samples │ iters
├─ part1        32.08 ms      │ 38.25 ms      │ 32.31 ms      │ 32.51 ms      │ 100     │ 100
╰─ part1_astar  81.47 ms      │ 90.38 ms      │ 81.94 ms      │ 82.19 ms      │ 100     │ 100

day_17          fastest       │ slowest       │ median        │ mean          │ samples │ iters
├─ part2        54.37 ms      │ 57.24 ms      │ 54.86 ms      │ 54.89 ms      │ 100     │ 100
╰─ part2_astar  81.39 ms      │ 82.7 ms       │ 81.68 ms      │ 81.73 ms      │ 100     │ 100
</code></pre>

    </div>
  </div>
</section>

    <!-- scripts -->
<script src="../../../scripts/highlight.js"></script>
<script>hljs.highlightAll();</script>
<script defer src="../../../scripts/katex.js"></script>
<script defer src="../../../scripts/auto-render.js" onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
    });
</script>

  </body>
</html>
